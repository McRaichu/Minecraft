// Date: 28.09.2015 15:02:10
// Template version 1.1
// Java generated by Techne
// Keep in mind that you still need to fill in some blanks
// - ZeuX






package com.mcraichu.obeliskoflight.harvester;

import org.lwjgl.opengl.GL11;

import net.minecraft.block.Block;
import net.minecraft.client.Minecraft;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelBiped;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.item.ItemBlock;
import net.minecraft.item.ItemStack;




public class ModelHarvester extends ModelBase
{
	// create an animation cycle
	// for movement based animations you need to measure distance moved
	// and perform number of cycles per block distance moved.

	protected boolean isFarming = false;

	protected double distanceMovedTotal = 0.0D;

	protected double prevDistanceMovedTotal = 0.0D;

	protected int farmingTicks = 0;


	// don't make this too large or animations will be skipped
	protected static final double CYCLES_PER_BLOCK = 1.7D; 
	protected static final int MOTIONLESS_LIMIT = 16; 
	protected int cycleIndex = 0;	

	protected float[][] farmingCycle = new float[][]
			{
			/*
			 * leg, clawX, clawY
			 * */	    	
			{ 0F, -70F, 30F },
			{ 0F, -70F, 30F },
			{ 0F, -70F, 25F },
			{ 0F, -70F, 25F },
			{ 0F, -70F, 20F },
			{ 0F, -70F, 20F },
			{ 0F, -70F, 15F },
			{ 0F, -70F, 15F },
			{ 0F, -70F, 10F },
			{ 0F, -70F, 10F },
			{ 0F, -70F,  5F },
			{ 0F, -70F,  5F },
			{ 0F, -70F,  0F },
			{ 0F, -70F,  0F },
			{ 0F, -70F,  5F },
			{ 0F, -70F,  5F },
			{ 0F, -70F, 10F },
			{ 0F, -70F, 10F },
			{ 0F, -70F, 15F },
			{ 0F, -70F, 15F },
			{ 0F, -70F, 20F },
			{ 0F, -70F, 20F },
			{ 0F, -70F, 25F },
			{ 0F, -70F, 25F }
			};

	protected float[][] walkingCycle = new float[][]
			{
			/*
			 * leg, clawX, clawY
			 * */	

			{ 0F, -70F, 30F },
			{ 45F, -70F, 30F },
			{ 90F, -70F, 30F },
			{ 135F, -70F, 30F },
			{ 180F, -70F, 30F },
			{ 225F, -70F, 30F },
			{ 270F, -70F, 30F },
			{ 315F, -70F, 30F },
			};

	//fields
	ModelRenderer head;
	ModelRenderer head2;
	ModelRenderer body;

	ModelRenderer head3;
	ModelRenderer clawleft2;
	ModelRenderer clawleft1;
	ModelRenderer clawright1;
	ModelRenderer clawright2;

	ModelRenderer leg1;
	ModelRenderer leg11;
	ModelRenderer leg12;

	ModelRenderer leg2;
	ModelRenderer leg21;
	ModelRenderer leg22;

	ModelRenderer leg3;
	ModelRenderer leg31;
	ModelRenderer leg32;

	ModelRenderer leg4;
	ModelRenderer leg41;  
	ModelRenderer leg42;





	public ModelHarvester()
	{
		textureWidth = 64;
		textureHeight = 64;

		head = new ModelRenderer(this, 0, 29);
		head.addBox(-5F, -2F, -10F, 10, 8, 12);
		head.setRotationPoint(0F, 11F, -2F);
		head.setTextureSize(64, 64);
		head.mirror = true;
		setRotation(head, 0F, 0F, 0F);
		head2 = new ModelRenderer(this, 16, 51);
		head2.addBox(-4F, -8.5F, -12F, 8, 6, 6);
		head2.setRotationPoint(0F, 11F, -2F);
		head2.setTextureSize(64, 64);
		head2.mirror = true;
		setRotation(head2, 0.7853982F, 0F, 0F);
		body = new ModelRenderer(this, 24, 0);
		body.addBox(-6F, -5F, -8F, 12, 19, 8);
		body.setRotationPoint(0F, 11F, -2F);
		body.setTextureSize(64, 64);
		body.mirror = true;
		setRotation(body, 1.570796F, 0F, 0F);
		head3 = new ModelRenderer(this, 36, 30);
		head3.addBox(-4F, -2F, -10F, 8, 3, 6);
		head3.setRotationPoint(0F, 11F, -2F);
		head3.setTextureSize(64, 64);
		head3.mirror = true;
		setRotation(head3, 0.7853982F, 0F, 0F);
		clawleft2 = new ModelRenderer(this, 10, 55);
		clawleft2.addBox(-4F, 9F, -1F, 4, 2, 2);
		clawleft2.setRotationPoint(4F, 18F, -8F);
		clawleft2.setTextureSize(64, 64);
		clawleft2.mirror = true;
		setRotation(clawleft2, 0F, 0F, 0F);
		clawleft1 = new ModelRenderer(this, 0, 51);
		clawleft1.addBox(0F, 0F, -1F, 2, 11, 2);
		clawleft1.setRotationPoint(4F, 18F, -8F);
		clawleft1.setTextureSize(64, 64);
		clawleft1.mirror = true;
		setRotation(clawleft1, 0F, 0F, 0F);
		clawright1 = new ModelRenderer(this, 0, 51);
		clawright1.addBox(-2F, 0F, -1F, 2, 11, 2);
		clawright1.setRotationPoint(-4F, 18F, -8F);
		clawright1.setTextureSize(64, 64);
		clawright1.mirror = true;
		setRotation(clawright1, 0F, 0F, 0F);
		clawright2 = new ModelRenderer(this, 10, 55);
		clawright2.addBox(0F, 9F, -1F, 4, 2, 2);
		clawright2.setRotationPoint(-4F, 18F, -8F);
		clawright2.setTextureSize(64, 64);
		clawright2.mirror = true;
		setRotation(clawright2, 0F, 0F, 0F);

		float x1 = -6F;
		float y1 = 20F;
		float z1 = -11F;
		leg1 = new ModelRenderer(this, 0, 13);
		leg1.addBox(-2F, -3F, -2F, 2, 6, 4);
		leg1.setRotationPoint(x1, y1, z1);
		leg1.setTextureSize(64, 64);
		leg1.mirror = true;
		setRotation(leg1, 0F, 0F, 0F);
		leg11 = new ModelRenderer(this, 0, 13);
		leg11.addBox(-2F, -2F, -3F, 2, 4, 1);
		leg11.setRotationPoint(x1, y1, z1);
		leg11.setTextureSize(64, 64);
		leg11.mirror = true;
		setRotation(leg11, 0F, 0F, 0F);
		leg12 = new ModelRenderer(this, 0, 13);
		leg12.addBox(-2F, -2F, 2F, 2, 4, 1);
		leg12.setRotationPoint(x1, y1, z1);
		leg12.setTextureSize(64, 64);
		leg12.mirror = true;
		setRotation(leg12, 0F, 0F, 0F);

		leg2 = new ModelRenderer(this, 0, 13);
		leg2.addBox(0F, -3F, -2F, 2, 6, 4);
		leg2.setRotationPoint(-x1, y1, z1);
		leg2.setTextureSize(64, 64);
		leg2.mirror = true;
		setRotation(leg2, 0F, 0F, 0F);
		leg21 = new ModelRenderer(this, 0, 13);
		leg21.addBox(0F, -2F, -3F, 2, 4, 1);
		leg21.setRotationPoint(-x1, y1, z1);
		leg21.setTextureSize(64, 64);
		leg21.mirror = true;
		setRotation(leg21, 0F, 0F, 0F);
		leg22 = new ModelRenderer(this, 0, 13);
		leg22.addBox(0F, -2F, 2F, 2, 4, 1);
		leg22.setRotationPoint(-x1, y1, z1);
		leg22.setTextureSize(64, 64);
		leg22.mirror = true;
		setRotation(leg22, 0F, 0F, 0F);


		x1 = -6F;
		y1 = 6F;
		z1 = -11F;
		leg3 = new ModelRenderer(this, 0, 13);
		leg3.addBox(-2F, -3F, -2F, 2, 6, 4);
		leg3.setRotationPoint(x1, y1, z1);
		leg3.setTextureSize(64, 64);
		leg3.mirror = true;
		setRotation(leg3, 0F, 0F, 0F);
		leg31 = new ModelRenderer(this, 0, 13);
		leg31.addBox(-2F, -2F, -3F, 2, 4, 1);
		leg31.setRotationPoint(x1, y1, z1);
		leg31.setTextureSize(64, 64);
		leg31.mirror = true;
		setRotation(leg31, 0F, 0F, 0F);
		leg32 = new ModelRenderer(this, 0, 13);
		leg32.addBox(-2F, -2F, 2F, 2, 4, 1);
		leg32.setRotationPoint(x1, y1, z1);
		leg32.setTextureSize(64, 64);
		leg32.mirror = true;
		setRotation(leg32, 0F, 0F, 0F);		

		leg4 = new ModelRenderer(this, 0, 13);
		leg4.addBox(0F, -3F, -2F, 2, 6, 4);
		leg4.setRotationPoint(-x1, y1, z1);
		leg4.setTextureSize(64, 64);
		leg4.mirror = true;
		setRotation(leg4, 0F, 0F, 0F);
		leg41 = new ModelRenderer(this, 0, 13);
		leg41.addBox(0F, -2F, 2F, 2, 4, 1);
		leg41.setRotationPoint(-x1, y1, z1);
		leg41.setTextureSize(64, 64);
		leg41.mirror = true;
		setRotation(leg41, 0F, 0F, 0F);		
		leg42 = new ModelRenderer(this, 0, 13);
		leg42.addBox(0F, -2F, -3F, 2, 4, 1);
		leg42.setRotationPoint(-x1, y1, z1);
		leg42.setTextureSize(64, 64);
		leg42.mirror = true;
		setRotation(leg42, 0F, 0F, 0F);








		convertToChild(leg1, leg11);
		convertToChild(leg1, leg12);

		convertToChild(leg2, leg21);
		convertToChild(leg2, leg22);

		convertToChild(leg3, leg31);
		convertToChild(leg3, leg32);

		convertToChild(leg4, leg41);
		convertToChild(leg4, leg42);

		//		leg1.addChild(leg11);
		//		leg1.addChild(leg12);

		//		leg2.addChild(leg21);
		//		leg2.addChild(leg22);
		//
		//		leg3.addChild(leg31);
		//		leg3.addChild(leg32);
		//
		//		leg4.addChild(leg41);
		//		leg4.addChild(leg42);
		//
		//		head.addChild(head2);
		//		head.addChild(head2);

		convertToChild(head, head2);
		convertToChild(head, head3);

		convertToChild(clawleft1, clawleft2);
		convertToChild(clawright1, clawright2);

		//		clawleft1.addChild(clawleft2);
		//		clawright1.addChild(clawright2);

		convertToChild(body, leg1);
		convertToChild(body, leg2);
		convertToChild(body, leg3);
		convertToChild(body, leg4);

		convertToChild(head, clawleft1);
		convertToChild(head, clawright1);

		convertToChild(body, head);




		//      ModelRenderer head;
		//      ModelRenderer head2;
		//      ModelRenderer body;
		//      
		//      ModelRenderer head3;
		//      ModelRenderer clawleft2;
		//      ModelRenderer clawleft1;
		//      ModelRenderer clawright1;
		//      ModelRenderer clawright2;

	}

	@Override
	public void render(Entity parEntity, float parTime, float parSwingSuppress, float par4, float parHeadAngleY, float parHeadAngleX, float par7)
	{
		renderHarvester((Harvester) parEntity, parTime, parSwingSuppress, par4, parHeadAngleY, parHeadAngleX, par7);
	}

	public void renderHarvester(Harvester parEntity, float parTime, float parSwingSuppress, float par4, float parHeadAngleY, float parHeadAngleX, float par7) {

		//		super.render(parEntity, f, f1, f2, f3, f4, f5);
		//		setRotationAngles(f, f1, f2, f3, f4, f5, parEntity);

		isFarming = parEntity.isHarvesting();

		setRotationAngles(parTime, parSwingSuppress, par4, parHeadAngleY, parHeadAngleX, par7, parEntity);

		GL11.glPushMatrix();
		//      GL11.glScalef(1.1F,1.1F,1.1F);
		GlStateManager.translate(0.0,0.5,0.0);
		GL11.glScalef(0.7F,0.7F,0.7F);//(1.0F,1.0F,1.0F);

		//System.out.println("-----------------------renderAtlas()");

		body.render(par7);

		GL11.glPopMatrix();

		ItemStack itemstack = parEntity.getHeldItem();

		if (itemstack != null)
		{
			GlStateManager.pushMatrix();

			this.head.postRender(0.0625F);
			GlStateManager.translate(0.0,0.55,1.2);  //(-0.0625F, 0.4375F, 0.0625F);
//			GlStateManager.scale(0.8, 0.8, 0.8);
			GlStateManager.rotate(80.0F, 1.0F, 0.0F, 0.0F);

			Item item = itemstack.getItem();
			Minecraft minecraft = Minecraft.getMinecraft();

			if (item instanceof ItemBlock && Block.getBlockFromItem(item).getRenderType() == 2)
			{
				GlStateManager.translate(0.0F, 0.1875F, -0.3125F);
				GlStateManager.rotate(20.0F, 1.0F, 0.0F, 0.0F);
				GlStateManager.rotate(45.0F, 0.0F, 1.0F, 0.0F);
				float f8 = 0.375F;
				GlStateManager.scale(-f8, -f8, f8);
			}

			minecraft.getItemRenderer().renderItem(parEntity, itemstack, ItemCameraTransforms.TransformType.THIRD_PERSON);
			GlStateManager.popMatrix();
		}

	}

	private void setRotation(ModelRenderer model, float x, float y, float z) {
		model.rotateAngleX = x;
		model.rotateAngleY = y;
		model.rotateAngleZ = z;
	}

	@Override
	public void setRotationAngles(float parTime, float parSwingSuppress, float par3, float parHeadAngleY, float parHeadAngleX, float par6, Entity parEntity)
	{
		updateDistanceMovedTotal(parEntity);

		cycleIndex = 0; //(int) ((getDistanceMovedTotal(parEntity)*CYCLES_PER_BLOCK)%walkingCycle.length);



		if(!isFarming)
		{
			cycleIndex = (int) ((getDistanceMovedTotal(parEntity)*CYCLES_PER_BLOCK)%walkingCycle.length);
			if(getDistanceMovedTotal(parEntity) < 0.05)
			{
				cycleIndex = 0;
			}
			farmingTicks = 0;
		}
		else
		{
			cycleIndex = (int) (farmingTicks%farmingCycle.length);
			farmingTicks++;
		}
		//        else if(!useStartingCycle)
		//        {
		//        	cycleIndex = 6;
		//        }

		// DEBUG
		//System.out.println("ModelSerpent setRotationAngles(), distanceMoved ="+getDistanceMovedTotal(parEntity)+", cycleIndex ="+cycleIndex+", motionX ="+parEntity.motionX);

		/*
		 * leg, clawX, clawY
		 * */	
		if(!isFarming)
		{
			leg1.rotateAngleX = degToRad(walkingCycle[cycleIndex][0]) ;
			leg2.rotateAngleX = degToRad(walkingCycle[cycleIndex][0]) ;
			leg3.rotateAngleX = degToRad(walkingCycle[cycleIndex][0]) ;
			leg4.rotateAngleX = degToRad(walkingCycle[cycleIndex][0]) ;

			clawleft1.rotateAngleX = degToRad(walkingCycle[cycleIndex][1]) ;
			clawright1.rotateAngleX = degToRad(walkingCycle[cycleIndex][1]) ;

			clawleft1.rotateAngleY = degToRad(- walkingCycle[cycleIndex][2]) ;
			clawright1.rotateAngleY = degToRad(walkingCycle[cycleIndex][2]) ;
		}else{
			leg1.rotateAngleX = degToRad(farmingCycle[cycleIndex][0]) ;
			leg2.rotateAngleX = degToRad(farmingCycle[cycleIndex][0]) ;
			leg3.rotateAngleX = degToRad(farmingCycle[cycleIndex][0]) ;
			leg4.rotateAngleX = degToRad(farmingCycle[cycleIndex][0]) ;

			clawleft1.rotateAngleX = degToRad(farmingCycle[cycleIndex][1]) ;
			clawright1.rotateAngleX = degToRad(farmingCycle[cycleIndex][1]) ;

			clawleft1.rotateAngleY = degToRad(- farmingCycle[cycleIndex][2]) ;
			clawright1.rotateAngleY = degToRad(farmingCycle[cycleIndex][2]) ;
		}
	}

	protected void updateDistanceMovedTotal(Entity parEntity) 
	{
		prevDistanceMovedTotal = distanceMovedTotal;
		distanceMovedTotal += parEntity.getDistance(parEntity.prevPosX, parEntity.prevPosY, parEntity.prevPosZ);
	}

	protected double getDistanceMovedTotal(Entity parEntity) 
	{
		return (distanceMovedTotal);
	}

	protected float degToRad(float degrees)
	{
		return degrees * (float)Math.PI / 180 ;
	}

	protected void setRotationDeg(ModelRenderer model, float rotX, float rotY, float rotZ)
	{
		model.rotateAngleX = degToRad(rotX);
		model.rotateAngleY = degToRad(rotY);
		model.rotateAngleZ = degToRad(rotZ);        
	}

	// This is really useful for converting the source from a Techne model
	// export
	// which will have absolute rotation points that need to be converted before
	// creating the addChild() relationship
	protected void convertToChild(ModelRenderer parParent,
			ModelRenderer parChild) {
		// move child rotation point to be relative to parent
		parChild.rotationPointX -= parParent.rotationPointX;
		parChild.rotationPointY -= parParent.rotationPointY;
		parChild.rotationPointZ -= parParent.rotationPointZ;
		// make rotations relative to parent
		parChild.rotateAngleX -= parParent.rotateAngleX;
		parChild.rotateAngleY -= parParent.rotateAngleY;
		parChild.rotateAngleZ -= parParent.rotateAngleZ;
		// create relationship
		parParent.addChild(parChild);
	}


}
